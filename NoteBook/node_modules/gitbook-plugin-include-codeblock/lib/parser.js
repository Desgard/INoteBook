// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.splitLabelToCommands = splitLabelToCommands;
exports.containIncludeCommand = containIncludeCommand;
exports.parseVariablesFromLabel = parseVariablesFromLabel;
exports.embedCode = embedCode;
exports.strip = strip;
exports.generateEmbedCode = generateEmbedCode;
exports.parse = parse;

var _languageDetection = require("./language-detection");

var _marker = require("./marker");

var _slicer = require("./slicer");

var _title = require("./title");

var fs = require("fs");
var path = require("path");
var Handlebars = require("handlebars");

var markdownLinkFormatRegExp = /\[([^\]]*?)\]\(([^\)]*?)\)/gm;

/**
 * A counter to count how many code are imported.
 */
var codeCounter = function () {
    var count = 0;
    return function () {
        return count++;
    }; // Return and increment
}();

/**
 * split label to commands
 * @param {string} label
 * @returns {Array}
 */
function splitLabelToCommands() {
    var label = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];

    var result = label.split(/(:|[,\s])/);
    if (!result) {
        return [];
    }
    // remove null command
    return result.map(function (command) {
        return command.trim();
    }).filter(function (command) {
        return command.length > 0;
    });
}
/**
 * if contain "include" or "import" command, then return true
 * @param {Array} commands
 * @returns {boolean}
 */
function containIncludeCommand() {
    var commands = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    var reg = /^(include|import)$/;
    return commands.some(function (command) {
        return reg.test(command.trim());
    });
}
/** Parse the command label and return key-value object
 * @example
 *      [import,title:"<thetitle>",label:"<thelabel>"](path/to/file.ext)
 * @param {string} label
 * @return {Object}
 */
function parseVariablesFromLabel(label) {
    var keyvals = {
        "title": undefined,
        "id": undefined,
        "class": undefined,
        "name": undefined,
        "marker": undefined,
        "unindent": undefined
    };
    Object.keys(keyvals).forEach(function (key) {
        var keyReg = key;
        if (key === "marker") {
            keyReg = "import|include";
        }
        var regStr = "\^.*,?\\s*(" + keyReg + ")\\s*:\\s*[\"']([^'\"]*)[\"'],?.*\$";
        var reg = new RegExp(regStr);
        var res = label.match(reg);
        if (res) {
            keyvals[key] = res[2];
        }
    });
    return keyvals;
}

/**
 * generate code with options
 * @param {string} lang
 * @param {string} filePath
 * @param {string} originalPath
 * @param {string} label
 * @param {string} template
 * @return {string}
 */
function embedCode(_ref) {
    var lang = _ref.lang;
    var filePath = _ref.filePath;
    var originalPath = _ref.originalPath;
    var label = _ref.label;
    var template = _ref.template;
    var unindent = _ref.unindent;

    var code = fs.readFileSync(filePath, "utf-8");
    var fileName = path.basename(filePath);
    var keyValueObject = parseVariablesFromLabel(label);
    var content = code;
    // Slice content via line numbers.
    if ((0, _slicer.hasSliceRange)(label)) {
        var _getSliceRange = (0, _slicer.getSliceRange)(label);

        var _getSliceRange2 = _slicedToArray(_getSliceRange, 2);

        var start = _getSliceRange2[0];
        var end = _getSliceRange2[1];

        content = (0, _slicer.sliceCode)(code, start, end);
    }
    // Slice content via markers.
    else if ((0, _marker.hasMarker)(keyValueObject)) {
            var marker = (0, _marker.getMarker)(keyValueObject);
            content = (0, _marker.removeMarkers)((0, _marker.markerSliceCode)(code, marker));
        }
    if (unindent || keyValueObject.unindent) {
        content = strip(content);
    }
    return generateEmbedCode({
        keyValueObject: keyValueObject,
        lang: lang,
        fileName: fileName,
        originalPath: originalPath,
        content: content,
        template: template
    });
}

function strip(s) {
    // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb
    var indents = s.split(/\n/).map(function (s) {
        return s.match(/^[ \t]*(?=\S)/);
    }).filter(function (m) {
        return m;
    }).map(function (m) {
        return m[0];
    });
    var smallestIndent = indents.sort(function (a, b) {
        return a.length - b.length;
    })[0];
    return s.replace(new RegExp("^" + smallestIndent, 'gm'), '');
}

/**
 * generate code from options
 * @param {Object} keyValueObject
 * @param {string} lang
 * @param {string} fileName
 * @param {string} originalPath
 * @param {string} content
 * @param {string} template handlebars template
 * @return {string}
 */
function generateEmbedCode(_ref2) {
    var keyValueObject = _ref2.keyValueObject;
    var lang = _ref2.lang;
    var fileName = _ref2.fileName;
    var originalPath = _ref2.originalPath;
    var content = _ref2.content;
    var template = _ref2.template;

    var count = (0, _title.hasTitle)(keyValueObject) ? codeCounter() : -1;
    // merge objects
    // if keyValueObject has `lang` key, that is overwrited by `lang` of right.
    var context = Object.assign({}, keyValueObject, { lang: lang, fileName: fileName, originalPath: originalPath, content: content, count: count });

    // compile template
    var handlebars = Handlebars.compile(template);
    // compile with data
    return handlebars(context);
}

var defaultOptions = {
    template: fs.readFileSync(path.join(__dirname, "..", "template", "default-template.hbs"), "utf-8"),
    unindent: false
};
/**
 * generate code with options
 * @param {string} content
 * @param {string} baseDir
 * @param {{template?: string}} options
 * @return {Array}
 */
function parse(content, baseDir) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var results = [];
    var template = options.template || defaultOptions.template;
    var unindent = options.unindent || defaultOptions.unindent;
    var res = void 0;
    while (res = markdownLinkFormatRegExp.exec(content)) {
        var _res = res;

        var _res2 = _slicedToArray(_res, 3);

        var all = _res2[0];
        var label = _res2[1];
        var originalPath = _res2[2];

        var commands = splitLabelToCommands(label);
        if (containIncludeCommand(commands)) {
            var lang = (0, _languageDetection.getLang)(commands, originalPath);
            var absolutePath = path.resolve(baseDir, originalPath);
            var replacedContent = embedCode({
                lang: lang,
                filePath: absolutePath,
                originalPath: originalPath,
                label: label,
                template: template,
                unindent: unindent
            });
            results.push({
                target: all,
                replaced: replacedContent
            });
        }
    }
    return results;
}
//# sourceMappingURL=parser.js.map