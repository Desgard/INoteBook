{"version":3,"sources":["../src/slicer.js"],"names":[],"mappings":";AACA;;;;;;;;;;;;;;;;;;;;;;;;;QAkBgB,a,GAAA,a;QAkBA,a,GAAA,a;QAaA,S,GAAA,S;AA/BT,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AACjC,QAAM,SAAS,0CAAf;AACA,QAAM,UAAU,OAAO,IAAP,CAAY,KAAZ,CAAhB;AACA,QAAI,YAAY,IAAhB,EAAsB;AAClB,eAAO,EAAP;AACH;;;AALgC,kCAOP,OAPO;;AAAA,QAO1B,GAP0B;AAAA,QAOrB,KAPqB;AAAA,QAOd,GAPc;;AAQjC,QAAM,mBAAmB,UAAU,EAAV,GAAe,SAAS,KAAT,EAAgB,EAAhB,CAAf,GAAqC,SAA9D;AACA,QAAM,iBAAiB,QAAQ,EAAR,GAAa,SAAS,GAAT,EAAc,EAAd,CAAb,GAAiC,SAAxD;AACA,WAAO,CAAC,gBAAD,EAAmB,cAAnB,CAAP;AACH;;;;;;;AAOM,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AACjC,QAAM,QAAQ,cAAc,KAAd,CAAd;;AADiC,gCAEZ,KAFY;;AAAA,QAE1B,KAF0B;AAAA,QAEnB,GAFmB;;AAGjC,WAAO,UAAU,SAAV,IAAuB,QAAQ,SAAtC;AACH;;;;;;;;;AASM,SAAS,SAAT,CAAmB,IAAnB,EAAyB,KAAzB,EAAgC,GAAhC,EAAqC;AACxC,QAAI,UAAU,SAAV,IAAuB,QAAQ,SAAnC,EAA8C;AAC1C,eAAO,IAAP;AACH;AACD,QAAM,UAAU,KAAK,KAAL,CAAW,IAAX,CAAhB;AACA,QAAI,UAAU,SAAd,EAAyB;AACrB,gBAAQ,CAAR;AACH;AACD,QAAI,QAAQ,SAAZ,EAAuB;AACnB,cAAM,QAAQ,MAAd;AACH;AACD,WAAO,QAAQ,KAAR,CAAc,QAAQ,CAAtB,EAAyB,GAAzB,EAA8B,IAA9B,CAAmC,IAAnC,EAAyC,IAAzC,EAAP;AACH","file":"slicer.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/*\n format: [import:<start-lineNumber>-<end-lineNumber>](path/to/file)\n lineNumber start with 1.\n\n Patterns:\n\n All: [import, hello-world.js](../src/hello-world.js)\n 1-2: [import:1-2, hello-world.js](../src/hello-world.js)\n 2-3: [import:2-3, hello-world.js](../src/hello-world.js)\n 2>=: [import:2-, hello-world.js](../src/hello-world.js)\n <=3: [import:-3, hello-world.js](../src/hello-world.js)\n */\n/**\n * get range from label\n * @param {string} label\n * @returns {number[]}\n */\nexport function getSliceRange(label) {\n    const regExp = /^(?:include|import):(\\d*)-(\\d*)[,\\s]?.*$/;\n    const matches = regExp.exec(label);\n    if (matches === null) {\n        return [];\n    }\n    // return [undefined, undefined] if not matched.\n    const [all, start, end] = matches;\n    const startOrUndefined = start !== \"\" ? parseInt(start, 10) : undefined;\n    const endOrUndefined = end !== \"\" ? parseInt(end, 10) : undefined;\n    return [startOrUndefined, endOrUndefined];\n}\n\n/**\n * has range command in the label\n * @param {string} label\n * @returns {boolean}\n */\nexport function hasSliceRange(label) {\n    const range = getSliceRange(label);\n    const [start, end] = range;\n    return start !== undefined || end !== undefined;\n}\n\n/**\n * slice {@link code} with {@link start} and {@link end}\n * @param {string} code\n * @param {number|undefined} [start]\n * @param {number|undefined} [end]\n * @returns {string}\n */\nexport function sliceCode(code, start, end) {\n    if (start === undefined && end === undefined) {\n        return code;\n    }\n    const slitted = code.split('\\n');\n    if (start === undefined) {\n        start = 1;\n    }\n    if (end === undefined) {\n        end = slitted.length;\n    }\n    return slitted.slice(start - 1, end).join('\\n').trim();\n}\n"]}