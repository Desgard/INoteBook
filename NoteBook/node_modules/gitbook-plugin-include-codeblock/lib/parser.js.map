{"version":3,"sources":["../src/parser.js"],"names":[],"mappings":";AACA;;;;;;;;QAyBgB,oB,GAAA,oB;QAiBA,qB,GAAA,qB;QAYA,uB,GAAA,uB;QAiCA,S,GAAA,S;QA4BA,K,GAAA,K;QAiBA,iB,GAAA,iB;QA+BA,K,GAAA,K;;AA/JhB;;AACA;;AACA;;AACA;;AANA,IAAM,KAAK,QAAQ,IAAR,CAAX;AACA,IAAM,OAAO,QAAQ,MAAR,CAAb;AACA,IAAM,aAAa,QAAQ,YAAR,CAAnB;;AAKA,IAAM,2BAA2B,8BAAjC;;;;;AAKA,IAAI,cAAe,YAAW;AAC1B,QAAI,QAAQ,CAAZ;AACA,WAAO,YAAW;AACd,eAAO,OAAP;AACH,KAFD,C;AAGH,CALiB,EAAlB;;;;;;;AAYO,SAAS,oBAAT,GAA0C;AAAA,QAAZ,KAAY,yDAAJ,EAAI;;AAC7C,QAAM,SAAS,MAAM,KAAN,CAAY,WAAZ,CAAf;AACA,QAAI,CAAC,MAAL,EAAa;AACT,eAAO,EAAP;AACH;;AAED,WAAO,OAAO,GAAP,CAAW,mBAAW;AACzB,eAAO,QAAQ,IAAR,EAAP;AACH,KAFM,EAEJ,MAFI,CAEG,mBAAW;AACjB,eAAO,QAAQ,MAAR,GAAiB,CAAxB;AACH,KAJM,CAAP;AAKH;;;;;;AAMM,SAAS,qBAAT,GAA8C;AAAA,QAAf,QAAe,yDAAJ,EAAI;;AACjD,QAAI,MAAM,oBAAV;AACA,WAAO,SAAS,IAAT,CAAc,mBAAW;AAC5B,eAAO,IAAI,IAAJ,CAAS,QAAQ,IAAR,EAAT,CAAP;AACH,KAFM,CAAP;AAGH;;;;;;;AAOM,SAAS,uBAAT,CAAiC,KAAjC,EAAwC;AAC3C,QAAI,UAAU;AACV,iBAAS,SADC;AAEV,cAAM,SAFI;AAGV,iBAAS,SAHC;AAIV,gBAAQ,SAJE;AAKV,kBAAU,SALA;AAMV,oBAAY;AANF,KAAd;AAQA,WAAO,IAAP,CAAY,OAAZ,EAAqB,OAArB,CAA6B,eAAO;AAChC,YAAI,SAAS,GAAb;AACA,YAAI,QAAQ,QAAZ,EAAsB;AAClB,qBAAS,gBAAT;AACH;AACD,YAAM,SAAS,gBAAgB,MAAhB,GAAyB,qCAAxC;AACA,YAAM,MAAM,IAAI,MAAJ,CAAW,MAAX,CAAZ;AACA,YAAM,MAAM,MAAM,KAAN,CAAY,GAAZ,CAAZ;AACA,YAAI,GAAJ,EAAS;AACL,oBAAQ,GAAR,IAAe,IAAI,CAAJ,CAAf;AACH;AACJ,KAXD;AAYA,WAAO,OAAP;AACH;;;;;;;;;;;AAWM,SAAS,SAAT,OAA8E;AAAA,QAA1D,IAA0D,QAA1D,IAA0D;AAAA,QAApD,QAAoD,QAApD,QAAoD;AAAA,QAA1C,YAA0C,QAA1C,YAA0C;AAAA,QAA5B,KAA4B,QAA5B,KAA4B;AAAA,QAArB,QAAqB,QAArB,QAAqB;AAAA,QAAX,QAAW,QAAX,QAAW;;AACjF,QAAM,OAAO,GAAG,YAAH,CAAgB,QAAhB,EAA0B,OAA1B,CAAb;AACA,QAAM,WAAW,KAAK,QAAL,CAAc,QAAd,CAAjB;AACA,QAAM,iBAAiB,wBAAwB,KAAxB,CAAvB;AACA,QAAI,UAAU,IAAd;;AAEA,QAAI,2BAAc,KAAd,CAAJ,EAA0B;AAAA,6BACD,2BAAc,KAAd,CADC;;AAAA;;AAAA,YACf,KADe;AAAA,YACR,GADQ;;AAEtB,kBAAU,uBAAU,IAAV,EAAgB,KAAhB,EAAuB,GAAvB,CAAV;AACH;;AAHD,SAKK,IAAI,uBAAU,cAAV,CAAJ,EAA+B;AAChC,gBAAM,SAAS,uBAAU,cAAV,CAAf;AACA,sBAAU,2BAAc,6BAAgB,IAAhB,EAAsB,MAAtB,CAAd,CAAV;AACH;AACD,QAAI,YAAY,eAAe,QAA/B,EAAyC;AACvC,kBAAU,MAAM,OAAN,CAAV;AACD;AACD,WAAO,kBAAkB;AACrB,sCADqB;AAErB,kBAFqB;AAGrB,0BAHqB;AAIrB,kCAJqB;AAKrB,wBALqB;AAMrB;AANqB,KAAlB,CAAP;AAQH;;AAEM,SAAS,KAAT,CAAe,CAAf,EAAkB;;AAEvB,QAAM,UAAU,EAAE,KAAF,CAAQ,IAAR,EAAc,GAAd,CAAkB;AAAA,eAAK,EAAE,KAAF,CAAQ,eAAR,CAAL;AAAA,KAAlB,EAAiD,MAAjD,CAAwD;AAAA,eAAK,CAAL;AAAA,KAAxD,EAAgE,GAAhE,CAAoE;AAAA,eAAK,EAAE,CAAF,CAAL;AAAA,KAApE,CAAhB;AACA,QAAM,iBAAiB,QAAQ,IAAR,CAAa,UAAC,CAAD,EAAG,CAAH;AAAA,eAAS,EAAE,MAAF,GAAS,EAAE,MAApB;AAAA,KAAb,EAAyC,CAAzC,CAAvB;AACA,WAAO,EAAE,OAAF,CAAU,IAAI,MAAJ,OAAe,cAAf,EAAiC,IAAjC,CAAV,EAAkD,EAAlD,CAAP;AACD;;;;;;;;;;;;AAYM,SAAS,iBAAT,QAOJ;AAAA,QANC,cAMD,SANC,cAMD;AAAA,QALC,IAKD,SALC,IAKD;AAAA,QAJC,QAID,SAJC,QAID;AAAA,QAHC,YAGD,SAHC,YAGD;AAAA,QAFC,OAED,SAFC,OAED;AAAA,QADC,QACD,SADC,QACD;;AACC,QAAM,QAAQ,qBAAS,cAAT,IAA2B,aAA3B,GAA2C,CAAC,CAA1D;;;AAGA,QAAM,UAAU,OAAO,MAAP,CAAc,EAAd,EAAkB,cAAlB,EAAkC,EAAC,UAAD,EAAO,kBAAP,EAAiB,0BAAjB,EAA+B,gBAA/B,EAAwC,YAAxC,EAAlC,CAAhB;;;AAGA,QAAM,aAAa,WAAW,OAAX,CAAmB,QAAnB,CAAnB;;AAEA,WAAO,WAAW,OAAX,CAAP;AACH;;AAGD,IAAM,iBAAiB;AACnB,cAAU,GAAG,YAAH,CAAgB,KAAK,IAAL,CAAU,SAAV,EAAqB,IAArB,EAA2B,UAA3B,EAAuC,sBAAvC,CAAhB,EAAgF,OAAhF,CADS;AAEnB,cAAU;AAFS,CAAvB;;;;;;;;AAWO,SAAS,KAAT,CAAe,OAAf,EAAwB,OAAxB,EAA+C;AAAA,QAAd,OAAc,yDAAJ,EAAI;;AAClD,QAAM,UAAU,EAAhB;AACA,QAAM,WAAW,QAAQ,QAAR,IAAoB,eAAe,QAApD;AACA,QAAM,WAAW,QAAQ,QAAR,IAAoB,eAAe,QAApD;AACA,QAAI,YAAJ;AACA,WAAO,MAAM,yBAAyB,IAAzB,CAA8B,OAA9B,CAAb,EAAqD;AAAA,mBACd,GADc;;AAAA;;AAAA,YAC1C,GAD0C;AAAA,YACrC,KADqC;AAAA,YAC9B,YAD8B;;AAEjD,YAAM,WAAW,qBAAqB,KAArB,CAAjB;AACA,YAAI,sBAAsB,QAAtB,CAAJ,EAAqC;AACjC,gBAAM,OAAO,gCAAQ,QAAR,EAAkB,YAAlB,CAAb;AACA,gBAAM,eAAe,KAAK,OAAL,CAAa,OAAb,EAAsB,YAAtB,CAArB;AACA,gBAAM,kBAAkB,UAAU;AAC9B,0BAD8B;AAE9B,0BAAU,YAFoB;AAG9B,8BAAc,YAHgB;AAI9B,4BAJ8B;AAK9B,kCAL8B;AAM9B;AAN8B,aAAV,CAAxB;AAQA,oBAAQ,IAAR,CAAa;AACT,wBAAQ,GADC;AAET,0BAAU;AAFD,aAAb;AAIH;AACJ;AACD,WAAO,OAAP;AACH","file":"parser.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst Handlebars = require(\"handlebars\");\nimport {getLang} from \"./language-detection\";\nimport {getMarker, hasMarker, markerSliceCode, removeMarkers} from \"./marker\";\nimport {sliceCode, hasSliceRange, getSliceRange} from \"./slicer\";\nimport {hasTitle, parseTitle} from \"./title\"\nconst markdownLinkFormatRegExp = /\\[([^\\]]*?)\\]\\(([^\\)]*?)\\)/gm;\n\n/**\n * A counter to count how many code are imported.\n */\nvar codeCounter = (function() {\n    var count = 0;\n    return function() {\n        return count++;\n    };  // Return and increment\n})();\n\n/**\n * split label to commands\n * @param {string} label\n * @returns {Array}\n */\nexport function splitLabelToCommands(label = \"\") {\n    const result = label.split(/(:|[,\\s])/);\n    if (!result) {\n        return [];\n    }\n    // remove null command\n    return result.map(command => {\n        return command.trim();\n    }).filter(command => {\n        return command.length > 0;\n    });\n}\n/**\n * if contain \"include\" or \"import\" command, then return true\n * @param {Array} commands\n * @returns {boolean}\n */\nexport function containIncludeCommand(commands = []) {\n    var reg = /^(include|import)$/;\n    return commands.some(command => {\n        return reg.test(command.trim());\n    })\n}\n/** Parse the command label and return key-value object\n * @example\n *      [import,title:\"<thetitle>\",label:\"<thelabel>\"](path/to/file.ext)\n * @param {string} label\n * @return {Object}\n */\nexport function parseVariablesFromLabel(label) {\n    var keyvals = {\n        \"title\": undefined,\n        \"id\": undefined,\n        \"class\": undefined,\n        \"name\": undefined,\n        \"marker\": undefined,\n        \"unindent\": undefined\n    };\n    Object.keys(keyvals).forEach(key => {\n        var keyReg = key;\n        if (key === \"marker\") {\n            keyReg = \"import|include\";\n        }\n        const regStr = \"\\^.*,?\\\\s*(\" + keyReg + \")\\\\s*:\\\\s*[\\\"']([^'\\\"]*)[\\\"'],?.*\\$\";\n        const reg = new RegExp(regStr);\n        const res = label.match(reg);\n        if (res) {\n            keyvals[key] = res[2];\n        }\n    });\n    return keyvals;\n}\n\n/**\n * generate code with options\n * @param {string} lang\n * @param {string} filePath\n * @param {string} originalPath\n * @param {string} label\n * @param {string} template\n * @return {string}\n */\nexport function embedCode({lang, filePath, originalPath, label, template, unindent}) {\n    const code = fs.readFileSync(filePath, \"utf-8\");\n    const fileName = path.basename(filePath);\n    const keyValueObject = parseVariablesFromLabel(label);\n    var content = code;\n    // Slice content via line numbers.\n    if (hasSliceRange(label)) {\n        const [start, end] = getSliceRange(label);\n        content = sliceCode(code, start, end);\n    }\n    // Slice content via markers.\n    else if (hasMarker(keyValueObject)) {\n        const marker = getMarker(keyValueObject);\n        content = removeMarkers(markerSliceCode(code, marker));\n    }\n    if (unindent || keyValueObject.unindent) {\n      content = strip(content)\n    }\n    return generateEmbedCode({\n        keyValueObject,\n        lang,\n        fileName,\n        originalPath,\n        content,\n        template\n    });\n}\n\nexport function strip(s) {\n  // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb\n  const indents = s.split(/\\n/).map(s => s.match(/^[ \\t]*(?=\\S)/)).filter(m => m).map(m => m[0])\n  const smallestIndent = indents.sort((a,b) => a.length-b.length)[0]\n  return s.replace(new RegExp(`^${smallestIndent}`, 'gm'), '')\n}\n\n/**\n * generate code from options\n * @param {Object} keyValueObject\n * @param {string} lang\n * @param {string} fileName\n * @param {string} originalPath\n * @param {string} content\n * @param {string} template handlebars template\n * @return {string}\n */\nexport function generateEmbedCode({\n    keyValueObject,\n    lang,\n    fileName,\n    originalPath,\n    content,\n    template\n}) {\n    const count = hasTitle(keyValueObject) ? codeCounter() : -1;\n    // merge objects\n    // if keyValueObject has `lang` key, that is overwrited by `lang` of right.\n    const context = Object.assign({}, keyValueObject, {lang, fileName, originalPath, content, count});\n\n    // compile template\n    const handlebars = Handlebars.compile(template);\n    // compile with data\n    return handlebars(context);\n}\n\n\nconst defaultOptions = {\n    template: fs.readFileSync(path.join(__dirname, \"..\", \"template\", \"default-template.hbs\"), \"utf-8\"),\n    unindent: false\n};\n/**\n * generate code with options\n * @param {string} content\n * @param {string} baseDir\n * @param {{template?: string}} options\n * @return {Array}\n */\nexport function parse(content, baseDir, options = {}) {\n    const results = [];\n    const template = options.template || defaultOptions.template;\n    const unindent = options.unindent || defaultOptions.unindent;\n    let res;\n    while (res = markdownLinkFormatRegExp.exec(content)) {\n        const [all, label, originalPath] = res;\n        const commands = splitLabelToCommands(label);\n        if (containIncludeCommand(commands)) {\n            const lang = getLang(commands, originalPath);\n            const absolutePath = path.resolve(baseDir, originalPath);\n            const replacedContent = embedCode({\n                lang,\n                filePath: absolutePath,\n                originalPath: originalPath,\n                label,\n                template,\n                unindent\n            });\n            results.push({\n                target: all,\n                replaced: replacedContent\n            });\n        }\n    }\n    return results;\n}\n"]}