"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMarker = getMarker;
exports.hasMarker = hasMarker;
exports.markerSliceCode = markerSliceCode;
exports.replaceAll = replaceAll;
exports.removeMarkers = removeMarkers;
// LICENSE : MIT
/*
 * Feature: doxygen like snippet code.
 * For code source documenting, see
 * https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdsnippet
 *
 * Gibook usage:
 *
 *      [import:<markername>](path/to/file)
 *
 * NB: markername must begin with a letter to avoid conflict with slice
 *     line range.
 */

var commentOpen = "(\/+\/+|#|%|\/\\*)";
var commentClose = "(\\*\/)?";
var doxChar = "[\*!\/]"; // doxygen documentation character
var spaces = "[ \t]*"; // h spaces
var spacesAny = "\\s*"; // h+v spaces
var markerNameFormat = "(\\s*[a-zA-Z][\\w\\s]*)"; // Must contain a char.

/*
 * format: [import:<markername>](path/to/file)
 * @param {Object} keyValObject
 * @return {string}
 */
function getMarker(keyValObject) {
    return keyValObject.marker;
}

/**
 * format: [import:<markername>](path/to/file)
 * check if the import filled has a markername.
 * @example:
 *      hasMarker(label)
 * @param {Object} keyValObject
 * @returns {boolean}
 */
function hasMarker(keyValObject) {
    var marker = getMarker(keyValObject);
    return marker !== undefined;
}

/* Parse the code from given markers
 *
 * see test/marker-test.js
 */
/**
 * get sliced code by {@link markername}
 * @param {string} code
 * @param {string} markername
 * @returns {string}
 */
function markerSliceCode(code, markername) {
    if (markername === undefined) {
        return code;
    }
    // regex
    var balise = "\\[" + markername + "\\]";
    var pattern = "\\n" + spacesAny + commentOpen + doxChar + spaces + balise + spaces + commentClose + spaces;

    var regstr = pattern + "\\n*([\\s\\S]*)" + pattern;
    var reg = new RegExp(regstr);
    var res = code.match(reg);

    if (res) {
        return res[3]; // count parenthesis in pattern.
    } else {
            console.warn('markersSliceCode(): marker `' + markername + '` not found');
            return 'Error: marker `' + markername + '` not found';
        }
}

/** Replace all regex occurence by sub in the string str,
 * @param {string} str
 * @param {string} reg
 * @param {string} sub
 * @return {string}
 */
function replaceAll(str, reg, sub) {
    return str.replace(new RegExp(reg, 'g'), sub);
}

/** Function that remove all markers in the given code
 * @param {string} code
 * @return {string}
 */
function removeMarkers(code) {
    // various language comment
    var balise = "\\[" + markerNameFormat + "\\]";
    var pattern = spacesAny + commentOpen + doxChar + spaces + balise + spaces + commentClose + spaces;

    return replaceAll(code, pattern, '');
}
//# sourceMappingURL=marker.js.map